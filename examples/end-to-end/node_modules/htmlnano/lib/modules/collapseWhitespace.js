"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = collapseWhitespace;

var _helpers = require("../helpers");

var noWhitespaceCollapseElements = new Set(['script', 'style', 'pre', 'textarea']);
var noTrimWhitespacesArroundElements = new Set([// non-empty tags that will maintain whitespace around them
'a', 'abbr', 'acronym', 'b', 'bdi', 'bdo', 'big', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'ins', 'kbd', 'label', 'mark', 'math', 'nobr', 'object', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'svg', 'textarea', 'time', 'tt', 'u', 'var', // self-closing tags that will maintain whitespace around them
'comment', 'img', 'input', 'wbr']);
var noTrimWhitespacesInsideElements = new Set([// non-empty tags that will maintain whitespace within them
'a', 'abbr', 'acronym', 'b', 'big', 'del', 'em', 'font', 'i', 'ins', 'kbd', 'mark', 'nobr', 'rp', 's', 'samp', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'time', 'tt', 'u', 'var']);
var whitespacePattern = /[\f\n\r\t\v ]{1,}/g;
var onlyWhitespacePattern = /^[\f\n\r\t\v ]+$/;
var NONE = '';
var SINGLE_SPACE = ' ';
var validOptions = ['all', 'aggressive', 'conservative'];
/** Collapses redundant whitespaces */

function collapseWhitespace(tree, options, collapseType, tag) {
  collapseType = validOptions.includes(collapseType) ? collapseType : 'conservative';
  tree.forEach(function (node, index) {
    if (typeof node === 'string' && !(0, _helpers.isComment)(node)) {
      var prevNode = tree[index - 1];
      var nextNode = tree[index + 1];
      var prevNodeTag = prevNode && prevNode.tag;
      var nextNodeTag = nextNode && nextNode.tag;
      var isTopLevel = !tag || tag === 'html' || tag === 'head';
      var shouldTrim = collapseType === 'all' || isTopLevel ||
      /*
       * When collapseType is set to 'aggressive', and the tag is not inside 'noTrimWhitespacesInsideElements'.
       * the first & last space inside the tag will be trimmed
       */
      collapseType === 'aggressive' && !noTrimWhitespacesInsideElements.has(tag);
      node = collapseRedundantWhitespaces(node, collapseType, shouldTrim, tag, prevNodeTag, nextNodeTag);
    }

    var isAllowCollapseWhitespace = !noWhitespaceCollapseElements.has(node.tag);

    if (node.content && node.content.length && isAllowCollapseWhitespace) {
      node.content = collapseWhitespace(node.content, options, collapseType, node.tag);
    }

    tree[index] = node;
  });
  return tree;
}

function collapseRedundantWhitespaces(text, collapseType) {
  var shouldTrim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var currentTag = arguments.length > 3 ? arguments[3] : undefined;
  var prevNodeTag = arguments.length > 4 ? arguments[4] : undefined;
  var nextNodeTag = arguments.length > 5 ? arguments[5] : undefined;

  if (!text || text.length === 0) {
    return NONE;
  }

  text = text.replace(whitespacePattern, SINGLE_SPACE);

  if (shouldTrim) {
    if (collapseType === 'aggressive') {
      if (onlyWhitespacePattern.test(text)) {
        // "text" only contains whitespaces. Only trim when both prevNodeTag & nextNodeTag are not "noTrimWhitespacesArroundElement"
        // Otherwise the required ONE whitespace will be trimmed
        if (!noTrimWhitespacesArroundElements.has(prevNodeTag) && !noTrimWhitespacesArroundElements.has(nextNodeTag)) {
          text = text.trim();
        }
      } else {
        // text contains whitespaces & non-whitespaces
        if (!noTrimWhitespacesArroundElements.has(prevNodeTag)) {
          text = text.trimStart();
        }

        if (!noTrimWhitespacesArroundElements.has(nextNodeTag)) {
          text = text.trimEnd();
        }
      }
    } else {
      // collapseType is 'all', trim spaces
      text = text.trim();
    }
  }

  return text;
}